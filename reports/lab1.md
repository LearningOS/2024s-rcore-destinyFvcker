# 实验四报告-chapter4 练习

- [实验四报告-chapter4 练习](#实验四报告-chapter4-练习)
  - [实现总结](#实现总结)
  - [简答作业](#简答作业)
  - [荣誉准则](#荣誉准则)

## 实现总结

**关于 `sys_get_time`:**

大概思路如下：

1. 首先，通过 `translated_byte_buffer` 函数将用户态传入的 `ts` 指针所指向的内存地址转换为内核态可以访问的缓冲区列表。
2. 接着，调用 `get_time_us` 函数获取当前时间的微秒数。
3. 创建一个 `TimeVal` 结构体对象 `time_val`，将秒和微秒分别计算并存储其中。
4. 将 `time_val` 结构体对象的内存地址转换为 `u8` 类型的指针 `time_val_ptr`。
5. 遍历缓冲区列表，通过 `copy_to` 方法将 `time_val` 结构体对象的内容复制到每个缓冲区中。
6. 更新 `time_val_ptr` 的位置，以便下一次复制。
7. 返回 0，表示系统调用执行成功。

值得注意的是，使用虚拟内存管理来重新实现该功能，可能意味着在重新实现时，可以考虑将 `TimeVal` 结构体跨越多个页面（页）来实现。

`sys_get_task_info` 的思路大概也是相同的

**关于 `mmap`和 `munmap`**

从一个非常粗糙的角度上来说就是分为两部：

1. 检查参数是否正确，包括对虚拟地址和控制位的检查、是否有足够的内存进行分配。
2. 进行相关操作，内存分配和内存释放。

这里的一个关键点我认为是在`MapArea`之中 VPNRange 的实现，这是一个右开区间，也就是说取不到 end。所以在进行`is_conflict`检查的时候对于每一个`areas`之中的`area`的时候不用检查到`end`。

其次在 free 内存的时候，除了调用 Pagetable 的 unmap 函数以外，还要 remove 掉对应的 area，释放相应的物理内存，我发现我这里的实现还是有一点粗糙，下一章再修复好了

## 简答作业

**SV39 页表页表项的组成：**
SV39 页表项通常由 64 位组成，其中包括页帧号（PFN）、标志位和保留位。具体来说，SV39 页表项的组成通常是：

1. **PFN（页帧号）**：占据了一定的位数（通常是 44 位），用于存储页面在物理内存中的地址。
2. **标志位**：包括有效位、读/写位、执行位、用户/内核位、全局位等，用于控制页面的访问权限和行为。
3. **保留位**：保留供将来使用，通常用于硬件或扩展。

**标志位的作用：**

- **有效位**：指示该页表项是否有效，即页面是否存在于物理内存中。
- **读/写位**：指示页面是否可读写。
- **执行位**：指示页面是否可执行。
- **用户/内核位**：指示页面是否为用户态可访问或内核态可访问。
- **全局位**：指示是否启用全局页面。

**可能导致缺页的异常：**
缺页可能导致以下异常：

- 缺页异常：当进程访问一个不在页表中的页面时触发的异常。
- 页故障异常：当内存管理单元检测到一个页面访问冲突时触发的异常。

**发生缺页时的相关重要寄存器的值：**

- PC（程序计数器）：存储下一条将要执行的指令的地址。
- 寄存器状态：存储着当前执行线程的寄存器内容，包括通用寄存器、堆栈指针等。

**Lazy 策略的好处：**
Lazy 策略可以延迟对页面的实际加载或分配，从而节省内存和资源。它的好处包括：

- 减少了初始化和分配页面的开销，提高了程序启动速度。
- 避免了不必要的页表操作，节省了内存带宽和 CPU 资源。
- 允许系统在真正需要时才分配物理内存，提高了内存的利用率。

**估算 SV39 页表占用的内存：**
SV39 页表采用三级页表结构，每级页表占用的内存大小取决于页表项的大小和页表的条目数。根据估算，SV39 页表大致占用数十 MB 到数百 MB 的内存空间。

**缺页时的处理：**
在缺页时，系统会根据具体的缺页原因采取不同的处理方式。如果是 Lazy 策略导致的缺页，系统会根据需要加载或分配页面，并更新页表；如果是 swap 策略导致的缺页，系统可能需要从磁盘中读取页面，并根据需要进行页面交换。

**页面失效在页表项上的表现：**
页面失效时，页表项的有效位会被清除，同时其他标志位可能会被修改以反映页面状态的变化，比如访问位和修改位可能会被置为 0。

**单页表情况下的页表更换：**
在单页表情况下，页表的更换通常发生在内核态和用户态之间的切换时。当发生内核态和用户态的切换时，操作系统会将相应的页表切换到页表寄存器中，从而实现不同特权级的地址映射。

**控制用户态无法访问内核页面：**
在单页表情况下，可以通过将内核页面映射到高地址空间，并设置相应的标志位，如用户/内核位，使得用户态无法访问内核页面。

**单页表的优势：**
单页表的优势在于简单高效，因为只需要维护一张页表，减少了页表切换的开销和复杂度。此外，单页表也有利于内存管理的统一和优化。

**双页表实现下的页表更换时机：**
在双页表实现下，页表的更换通常发生在进程切换或地址空间切换时。当进程切换或地址空间切换时，操作系统会将相应的页表切换到页表寄存器中，以实现不同进程或地址空间的地址映射。如果是单页表操作系统，可能会选择在进程切换时更换页表，以确保地址空间的隔离和安全。

## 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

   - 我并没有和任何人进行交流，单独完成了此次任务

2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

   - rCore-Tutorial- Book-v3 3.6.0- alpha.1 文档

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。
