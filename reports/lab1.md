# 实验 3 报告-chapter3 练习

- [实验 3 报告-chapter3 练习](#实验-3-报告-chapter3-练习)
  - [实现总结](#实现总结)
    - [timer.rs](#timerrs)
    - [task 模块](#task-模块)
    - [syscall 模块](#syscall-模块)
  - [简答作业](#简答作业)
    - [问题 1](#问题-1)
    - [问题 2.1](#问题-21)
    - [问题 2.2](#问题-22)
    - [问题 2.3](#问题-23)
    - [问题 2.4](#问题-24)
    - [问题 2.5](#问题-25)
    - [问题 2.6](#问题-26)
    - [问题 2.7](#问题-27)
  - [建议](#建议)
  - [荣誉准则](#荣誉准则)

## 实现总结

这里主要是在下面这几个文件之中进行了改动：

### timer.rs

我把原来在 `process.rs`之中实现的 TimeVal 移动到了这个模块之中，原因是我感觉在我实现了作业之中的系统调用之后 TimeVal 应该还是一个全局都可使用的重要数据结构，而非进行系统调用才要用到的数据结构，移动到`time.rs`之中并将其暴露出来，直接在 `process.rs` 之中进行暴露的话会对整个系统的封装有不好的影响。

其次，为 TimeVal 实现了两个方法：`update` 和 `as_ms`，分别用于更新时间和将时间转换为毫秒（ms），方便之后的计算。

### task 模块

在`task/task.rs`之中主要是给任务控制块添加了 3 个字段：`syscall_times`、`start_time`、`last_syscall_time`，使其可以做更多的簿记工作，完成本次系统调用的功能。我还实现了一些方法来实现这些簿记工作，像是更新 `start_time`，获得 `syscall_time`的拷贝之类的。

在`task/mod.rs`之中就是对上面`task/task.rs`之中的功能进行封装，主要就是通过全局变量`TASKMANAGER`来进行操作。在任务开始运行的时候记录它的 `start_time`，在任务进行系统调用的时候记录它的 `last_syscall_time`，最后系统调用返回的那个 time，相减就可以了。

### syscall 模块

首先最重要的是在`syscall/process.rs`之中完成系统调用的实现

然后就是在`syscall/mod.rs`之中在 match 跳转到对应的系统调用进行执行之前，对对应系统调用的次数还有最后一次系统调用的时间进行更新、

## 简答作业

### 问题 1

```Text
[kernel] PageFault in application, bad addr = 0x0, bad instruction = 0x80400062, kernel killed it.
[kernel] IllegalInstruction in application, kernel killed it.
[kernel] IllegalInstruction in application, kernel killed it.
All applications completed!
```

第一个是一个页错误，其余两个是指令错误

### 问题 2.1

**首先应该明白一个问题：当 trap_handler 返回之后会从调用 trap_handler 的下一条指令来事执行，也就是从栈上的 Trap 上下文恢复的\_\_restor**

其次，a0 代表了参数寄存器，并且在 RISC-V 之中，函数调用的返回值通常会被存储在 a0 寄存器之中。并且这里和第二章的批处理系统不一样，不是直接调用\_\_restore 来返回到用户态的，而是使用 switch，所以这里不需要使用这个操作。

在批处理系统之中，因为在运行下一个程序的时候需要压入一个内核上下文（保存的就是要返回的用户态应用程序的相关信息），这个 a0 就是新的栈顶，所以要更新 sp，使其指向新的栈顶。

### 问题 2.2

这里恢复了三个 CSR 寄存器：sstatus、sepc、sscratch，对恢复用户态执行环境来说，这里的 sepc 指令存储了回到用户态之后下一条应该执行的指令地址，而 sscratch 保存了用户栈的 sp 指针，而 sstatus 记录了在 Trap 发生前 CPU 处于哪个特权级，等一下的 sret 指令需要修改这个寄存器之中的值以回到用户态。

### 问题 2.3

因为 x2 是栈指针寄存器，在这里先不保存，因为接下来要根据它的值（指示栈帧的位置）来保存对应的寄存器，而 x4 因为经常用不到，所以在这里不需要进行保存

### 问题 2.4

这条指令主要就是保存栈指针，将 sp 寄存器之中的值和 sscratch 寄存器之中的值进行交换，这行代码的使用场景是在系统调用的时候换栈，让 sp 从指向用户栈到指向内核栈或让 sp 从指向内核栈到指向用户栈。

在 L60 的指令之后 sp 指向用户栈，sscratch 指向内核栈

### 问题 2.5

是最后一行的 sret 指令，因为这条指令会把现在的特权级设置为 U，然后会跳转到 sepc 寄存器指向的那条指令，然后继续执行，而我们已经让 sepc 寄存器指向了用户态的下一条代码

### 问题 2.6

sp 指向内核栈，sscratch 指向用户栈，系统调用的时候要在内核栈之中保存用户执行环境的执行环境信息

### 问题 2.7

ecall （Environment call）指令，准确来说，应该是 Environment call from U-mode。

## 建议

我认为应该把 Linux 操作系统之中这个计算时间的原理在文档之中用一个小节好好讲一下，我第一次运行没有通过测试就是因为没有搞清楚计算时间的原理 🥲，后面去看测试代码是怎么计算时间的才搞明白。

## 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

   - 我并没有和任何人进行交流

2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

   - rCore-Tutorial- Book-v3 3.6.0- alpha.1 文档

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。
