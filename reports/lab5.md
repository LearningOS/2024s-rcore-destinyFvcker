# 实验五报告-chapter8 练习

- [实验五报告-chapter8 练习](#实验五报告-chapter8-练习)
  - [实验总结](#实验总结)
  - [简答作业](#简答作业)
    - [资源回收](#资源回收)
    - [TaskControlBlock 的引用位置](#taskcontrolblock-的引用位置)
    - [Mutex.unlock 的实现对比](#mutexunlock-的实现对比)
      - [Mutex1 的实现](#mutex1-的实现)
      - [Mutex2 的实现](#mutex2-的实现)
    - [区别和潜在问题](#区别和潜在问题)
    - [结论](#结论)
  - [关于实验的建议](#关于实验的建议)
  - [荣誉准则](#荣誉准则)

## 实验总结

关于 mutex 的死锁检测实际上很好完成，这里主要就是 semaphore 的死锁检测花了很多时间。

涉及到了很多簿记工作：首先就是在 process 之中，需要加入一个字段`is_dl_det_enable`说明现在 死锁检测已经打开， 其次就是需要在每一个线程的线程控制块之中标明现在此线程占有了哪些资源`allocation`, 需要哪些资源（在哪些 semaohore 上阻塞）`need`，它们都是元祖的列表，其中每一个元素都是一个`(SemId, count)`的形式。

然后就是要在 semaphore.rs 的 down 方法之中加入死锁检测的相关内容，大概就是将上面的簿记内容全部拷贝出来，形成对应的 Work、Allocation、Need 矩阵，遍历即可。

## 简答作业

### 资源回收

当主线程（0 号线程）退出时，需要回收以下资源：

1. **线程栈**：每个线程都有自己的栈空间，主线程退出时需要释放这些栈空间。
2. **线程控制块（Task Control Block, TCB）**：每个线程的状态和上下文信息存储在 TCB 中，需要回收这些数据结构。
3. **锁和同步原语**：所有被线程持有的锁和其他同步原语（如信号量、条件变量）需要被释放。
4. **文件和资源句柄**：所有线程持有的文件描述符和其他资源句柄需要关闭。

### TaskControlBlock 的引用位置

`TaskControlBlock` 可能被以下位置引用：

1. **调度队列**：调度器维护的队列中可能包含对线程 TCB 的引用。这些引用需要回收，因为线程已经终止。
2. **等待队列**：如果线程在等待某个资源（如锁、条件变量），它的 TCB 可能在等待队列中。这些引用也需要回收。
3. **其他线程**：其他线程可能持有某些线程的 TCB 的引用，用于线程间通信或同步。如果主线程退出，这些引用需要处理以防止悬挂引用（Dangling References）。

所有这些引用需要回收，因为线程已经退出，保留这些引用会导致内存泄漏或悬挂引用问题。

### Mutex.unlock 的实现对比

以下是两种 `Mutex.unlock` 的实现：

#### Mutex1 的实现

```rust
impl Mutex for Mutex1 {
    fn unlock(&self) {
        let mut mutex_inner = self.inner.exclusive_access();
        assert!(mutex_inner.locked);
        mutex_inner.locked = false;
        if let Some(waking_task) = mutex_inner.wait_queue.pop_front() {
            add_task(waking_task);
        }
    }
}
```

#### Mutex2 的实现

```rust
impl Mutex for Mutex2 {
    fn unlock(&self) {
        let mut mutex_inner = self.inner.exclusive_access();
        assert!(mutex_inner.locked);
        if let Some(waking_task) = mutex_inner.wait_queue.pop_front() {
            add_task(waking_task);
        } else {
            mutex_inner.locked = false;
        }
    }
}
```

### 区别和潜在问题

1. **锁的释放时机**：

   - `Mutex1`：无论 `wait_queue` 是否有任务，都会在解锁后设置 `locked = false`。
   - `Mutex2`：只有当 `wait_queue` 为空时，才会设置 `locked = false`。

2. **潜在问题**：

   - **死锁问题**：`Mutex1` 的实现可能导致一个任务被唤醒后，认为锁已经释放，导致竞争条件和死锁。
   - **锁状态不一致**：`Mutex2` 通过条件设置锁的状态，当 `wait_queue` 不为空时，锁的状态保持为 `true`，这可能导致锁的状态不一致，因为锁在某些情况下保持为锁定状态，虽然实际上没有任务持有该锁。

3. **性能和正确性**：
   - `Mutex1`：简单直接，但可能导致在任务唤醒时锁状态与实际状态不一致。
   - `Mutex2`：更加严格地控制锁状态，但可能导致一些任务在队列中等待却没有被唤醒，因为锁仍然显示为已锁定状态。

### 结论

- **Mutex1** 实现更容易理解，但在任务唤醒和锁释放的时机上可能会出现问题，导致锁状态不一致，进而引发死锁问题。
- **Mutex2** 实现更为谨慎，但在某些情况下可能会导致任务等待队列中有任务等待时，锁没有被正确释放的问题。

要避免这些问题，需要确保锁的状态与实际任务的执行顺序和等待队列状态一致。可能需要在实现中加入更多的同步机制和状态检查，以保证锁的正确性和系统的稳定性。

## 关于实验的建议

在作业要求里面有提示：描述内容好像就是说在本次练习之中只需要完成死锁检测的相关系统调用功能，实际上还需要完成 sys_get_time 的系统调用，不然程序根本跑不起来，所以希望以后能在文档之中加入相关提示。

## 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

   - 我并没有和任何人进行交流，单独完成了此次任务

2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

   - rCore-Tutorial-Book-v3 3.6.0- alpha.1 文档
   - rCore-Tutorial-Guide-2024S 文档

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。
